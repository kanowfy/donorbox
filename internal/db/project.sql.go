// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: project.sql

package db

import (
	"context"
	"time"
)

const createMilestone = `-- name: CreateMilestone :one
INSERT INTO milestones (
    project_id, title, description, fund_goal, bank_description
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, project_id, title, description, fund_goal, current_fund, bank_description, completed, created_at
`

type CreateMilestoneParams struct {
	ProjectID       int64
	Title           string
	Description     *string
	FundGoal        int64
	BankDescription string
}

func (q *Queries) CreateMilestone(ctx context.Context, arg CreateMilestoneParams) (Milestone, error) {
	row := q.db.QueryRow(ctx, createMilestone,
		arg.ProjectID,
		arg.Title,
		arg.Description,
		arg.FundGoal,
		arg.BankDescription,
	)
	var i Milestone
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.FundGoal,
		&i.CurrentFund,
		&i.BankDescription,
		&i.Completed,
		&i.CreatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    user_id, category_id, title, description, cover_picture, end_date, receiver_number, receiver_name, address, district, city, country
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, user_id, title, description, cover_picture, category_id, end_date, receiver_number, receiver_name, address, district, city, country, status, created_at
`

type CreateProjectParams struct {
	UserID         int64
	CategoryID     int32
	Title          string
	Description    string
	CoverPicture   string
	EndDate        time.Time
	ReceiverNumber string
	ReceiverName   string
	Address        string
	District       string
	City           string
	Country        string
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.UserID,
		arg.CategoryID,
		arg.Title,
		arg.Description,
		arg.CoverPicture,
		arg.EndDate,
		arg.ReceiverNumber,
		arg.ReceiverName,
		arg.Address,
		arg.District,
		arg.City,
		arg.Country,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CoverPicture,
		&i.CategoryID,
		&i.EndDate,
		&i.ReceiverNumber,
		&i.ReceiverName,
		&i.Address,
		&i.District,
		&i.City,
		&i.Country,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createProjectUpdate = `-- name: CreateProjectUpdate :one
INSERT INTO project_updates (
    project_id, attachment_photo, description
) VALUES (
    $1, $2, $3
)
RETURNING id, project_id, attachment_photo, description, created_at
`

type CreateProjectUpdateParams struct {
	ProjectID       int64
	AttachmentPhoto *string
	Description     string
}

func (q *Queries) CreateProjectUpdate(ctx context.Context, arg CreateProjectUpdateParams) (ProjectUpdate, error) {
	row := q.db.QueryRow(ctx, createProjectUpdate, arg.ProjectID, arg.AttachmentPhoto, arg.Description)
	var i ProjectUpdate
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.AttachmentPhoto,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const deleteProjectByID = `-- name: DeleteProjectByID :exec
DELETE FROM projects WHERE id = $1
`

func (q *Queries) DeleteProjectByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProjectByID, id)
	return err
}

const deleteProjectUpdate = `-- name: DeleteProjectUpdate :exec
DELETE FROM project_updates
WHERE id = $1
`

func (q *Queries) DeleteProjectUpdate(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProjectUpdate, id)
	return err
}

const getAllCategories = `-- name: GetAllCategories :many
SELECT id, name, description, cover_picture FROM categories
`

func (q *Queries) GetAllCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, getAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CoverPicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjects = `-- name: GetAllProjects :many
SELECT projects.id, projects.user_id, projects.title, projects.description, projects.cover_picture, projects.category_id, projects.end_date, projects.receiver_number, projects.receiver_name, projects.address, projects.district, projects.city, projects.country, projects.status, projects.created_at, SUM(milestones.current_fund) AS total_fund,
SUM(milestones.fund_goal) AS fund_goal, COUNT(backings.project_id) as backing_count
FROM projects
LEFT JOIN backings ON projects.ID = backings.project_id
LEFT JOIN milestones ON projects.ID = milestones.project_id
WHERE category_id = 
    CASE WHEN $1::integer > 0 THEN $1::integer ELSE category_id END
AND projects.status = 'ongoing'
GROUP BY projects.ID
ORDER BY backing_count DESC
LIMIT $3::integer OFFSET $2::integer
`

type GetAllProjectsParams struct {
	Category    int32
	TotalOffset int32
	PageLimit   int32
}

type GetAllProjectsRow struct {
	ID             int64
	UserID         int64
	Title          string
	Description    string
	CoverPicture   string
	CategoryID     int32
	EndDate        time.Time
	ReceiverNumber string
	ReceiverName   string
	Address        string
	District       string
	City           string
	Country        string
	Status         NullProjectStatus
	CreatedAt      time.Time
	TotalFund      int64
	FundGoal       int64
	BackingCount   int64
}

func (q *Queries) GetAllProjects(ctx context.Context, arg GetAllProjectsParams) ([]GetAllProjectsRow, error) {
	rows, err := q.db.Query(ctx, getAllProjects, arg.Category, arg.TotalOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectsRow
	for rows.Next() {
		var i GetAllProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.CoverPicture,
			&i.CategoryID,
			&i.EndDate,
			&i.ReceiverNumber,
			&i.ReceiverName,
			&i.Address,
			&i.District,
			&i.City,
			&i.Country,
			&i.Status,
			&i.CreatedAt,
			&i.TotalFund,
			&i.FundGoal,
			&i.BackingCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentMilestone = `-- name: GetCurrentMilestone :one
SELECT id, project_id, title, description, fund_goal, current_fund, bank_description, completed, created_at FROM milestones
WHERE project_id = $1 AND current_fund < fund_goal
ORDER BY id ASC
LIMIT 1
`

func (q *Queries) GetCurrentMilestone(ctx context.Context, projectID int64) (Milestone, error) {
	row := q.db.QueryRow(ctx, getCurrentMilestone, projectID)
	var i Milestone
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.FundGoal,
		&i.CurrentFund,
		&i.BankDescription,
		&i.Completed,
		&i.CreatedAt,
	)
	return i, err
}

const getFinishedProjects = `-- name: GetFinishedProjects :many
SELECT projects.id, projects.user_id, projects.title, projects.description, projects.cover_picture, projects.category_id, projects.end_date, projects.receiver_number, projects.receiver_name, projects.address, projects.district, projects.city, projects.country, projects.status, projects.created_at, SUM(milestones.current_fund) AS total_fund,
SUM(milestones.fund_goal) AS fund_goal, COUNT(backings.project_id) as backing_count
FROM projects
JOIN backings ON projects.ID = backings.project_id
LEFT JOIN milestones ON projects.ID = milestones.project_id
WHERE projects.status = 'finished'
GROUP BY projects.ID
ORDER BY end_date DESC
`

type GetFinishedProjectsRow struct {
	ID             int64
	UserID         int64
	Title          string
	Description    string
	CoverPicture   string
	CategoryID     int32
	EndDate        time.Time
	ReceiverNumber string
	ReceiverName   string
	Address        string
	District       string
	City           string
	Country        string
	Status         NullProjectStatus
	CreatedAt      time.Time
	TotalFund      int64
	FundGoal       int64
	BackingCount   int64
}

func (q *Queries) GetFinishedProjects(ctx context.Context) ([]GetFinishedProjectsRow, error) {
	rows, err := q.db.Query(ctx, getFinishedProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFinishedProjectsRow
	for rows.Next() {
		var i GetFinishedProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.CoverPicture,
			&i.CategoryID,
			&i.EndDate,
			&i.ReceiverNumber,
			&i.ReceiverName,
			&i.Address,
			&i.District,
			&i.City,
			&i.Country,
			&i.Status,
			&i.CreatedAt,
			&i.TotalFund,
			&i.FundGoal,
			&i.BackingCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMilestoneByID = `-- name: GetMilestoneByID :one
SELECT id, project_id, title, description, fund_goal, current_fund, bank_description, completed, created_at FROM milestones
WHERE id = $1
`

func (q *Queries) GetMilestoneByID(ctx context.Context, id int64) (Milestone, error) {
	row := q.db.QueryRow(ctx, getMilestoneByID, id)
	var i Milestone
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.FundGoal,
		&i.CurrentFund,
		&i.BankDescription,
		&i.Completed,
		&i.CreatedAt,
	)
	return i, err
}

const getMilestoneForProject = `-- name: GetMilestoneForProject :many
SELECT id, project_id, title, description, fund_goal, current_fund, bank_description, completed, created_at FROM milestones
WHERE project_id = $1
`

func (q *Queries) GetMilestoneForProject(ctx context.Context, projectID int64) ([]Milestone, error) {
	rows, err := q.db.Query(ctx, getMilestoneForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Milestone
	for rows.Next() {
		var i Milestone
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.FundGoal,
			&i.CurrentFund,
			&i.BankDescription,
			&i.Completed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT projects.id, projects.user_id, projects.title, projects.description, projects.cover_picture, projects.category_id, projects.end_date, projects.receiver_number, projects.receiver_name, projects.address, projects.district, projects.city, projects.country, projects.status, projects.created_at, SUM(milestones.current_fund) AS total_fund, SUM(milestones.fund_goal) AS fund_goal
FROM projects
LEFT JOIN milestones ON projects.ID = milestones.project_id
WHERE projects.ID = $1
GROUP BY projects.ID
`

type GetProjectByIDRow struct {
	ID             int64
	UserID         int64
	Title          string
	Description    string
	CoverPicture   string
	CategoryID     int32
	EndDate        time.Time
	ReceiverNumber string
	ReceiverName   string
	Address        string
	District       string
	City           string
	Country        string
	Status         NullProjectStatus
	CreatedAt      time.Time
	TotalFund      int64
	FundGoal       int64
}

func (q *Queries) GetProjectByID(ctx context.Context, id int64) (GetProjectByIDRow, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i GetProjectByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CoverPicture,
		&i.CategoryID,
		&i.EndDate,
		&i.ReceiverNumber,
		&i.ReceiverName,
		&i.Address,
		&i.District,
		&i.City,
		&i.Country,
		&i.Status,
		&i.CreatedAt,
		&i.TotalFund,
		&i.FundGoal,
	)
	return i, err
}

const getProjectUpdates = `-- name: GetProjectUpdates :many
SELECT id, project_id, attachment_photo, description, created_at FROM project_updates
WHERE project_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetProjectUpdates(ctx context.Context, projectID int64) ([]ProjectUpdate, error) {
	rows, err := q.db.Query(ctx, getProjectUpdates, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectUpdate
	for rows.Next() {
		var i ProjectUpdate
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.AttachmentPhoto,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsForUser = `-- name: GetProjectsForUser :many
SELECT projects.id, projects.user_id, projects.title, projects.description, projects.cover_picture, projects.category_id, projects.end_date, projects.receiver_number, projects.receiver_name, projects.address, projects.district, projects.city, projects.country, projects.status, projects.created_at, SUM(milestones.current_fund) AS total_fund, SUM(milestones.fund_goal) AS fund_goal
FROM projects
LEFT JOIN milestones ON projects.ID = milestones.project_id
WHERE user_id = $1
GROUP BY projects.ID
ORDER BY projects.created_at DESC
`

type GetProjectsForUserRow struct {
	ID             int64
	UserID         int64
	Title          string
	Description    string
	CoverPicture   string
	CategoryID     int32
	EndDate        time.Time
	ReceiverNumber string
	ReceiverName   string
	Address        string
	District       string
	City           string
	Country        string
	Status         NullProjectStatus
	CreatedAt      time.Time
	TotalFund      int64
	FundGoal       int64
}

func (q *Queries) GetProjectsForUser(ctx context.Context, userID int64) ([]GetProjectsForUserRow, error) {
	rows, err := q.db.Query(ctx, getProjectsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsForUserRow
	for rows.Next() {
		var i GetProjectsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.CoverPicture,
			&i.CategoryID,
			&i.EndDate,
			&i.ReceiverNumber,
			&i.ReceiverName,
			&i.Address,
			&i.District,
			&i.City,
			&i.Country,
			&i.Status,
			&i.CreatedAt,
			&i.TotalFund,
			&i.FundGoal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnresolvedMilestones = `-- name: GetUnresolvedMilestones :many
SELECT id, project_id, title, description, fund_goal, current_fund, bank_description, completed, created_at FROM milestones
WHERE current_fund >= fund_goal
AND completed IS FALSE
ORDER BY created_at ASC
`

func (q *Queries) GetUnresolvedMilestones(ctx context.Context) ([]Milestone, error) {
	rows, err := q.db.Query(ctx, getUnresolvedMilestones)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Milestone
	for rows.Next() {
		var i Milestone
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.FundGoal,
			&i.CurrentFund,
			&i.BankDescription,
			&i.Completed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjects = `-- name: SearchProjects :many
SELECT projects.id, projects.user_id, projects.title, projects.description, projects.cover_picture, projects.category_id, projects.end_date, projects.receiver_number, projects.receiver_name, projects.address, projects.district, projects.city, projects.country, projects.status, projects.created_at, SUM(milestones.current_fund) AS total_fund,
SUM(milestones.fund_goal) AS fund_goal, COUNT(backings.project_id) as backing_count
FROM projects
LEFT JOIN backings ON projects.ID = backings.project_id
LEFT JOIN milestones ON projects.ID = milestones.project_id
WHERE 
    to_tsvector('english', projects.title || ' ' || projects.description || ' ' || city || ' ' || country) @@ plainto_tsquery('english', $1::text)
AND projects.status = 'ongoing'
GROUP BY projects.ID
LIMIT $3::integer OFFSET $2::integer
`

type SearchProjectsParams struct {
	SearchQuery string
	TotalOffset int32
	PageLimit   int32
}

type SearchProjectsRow struct {
	ID             int64
	UserID         int64
	Title          string
	Description    string
	CoverPicture   string
	CategoryID     int32
	EndDate        time.Time
	ReceiverNumber string
	ReceiverName   string
	Address        string
	District       string
	City           string
	Country        string
	Status         NullProjectStatus
	CreatedAt      time.Time
	TotalFund      int64
	FundGoal       int64
	BackingCount   int64
}

func (q *Queries) SearchProjects(ctx context.Context, arg SearchProjectsParams) ([]SearchProjectsRow, error) {
	rows, err := q.db.Query(ctx, searchProjects, arg.SearchQuery, arg.TotalOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProjectsRow
	for rows.Next() {
		var i SearchProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.CoverPicture,
			&i.CategoryID,
			&i.EndDate,
			&i.ReceiverNumber,
			&i.ReceiverName,
			&i.Address,
			&i.District,
			&i.City,
			&i.Country,
			&i.Status,
			&i.CreatedAt,
			&i.TotalFund,
			&i.FundGoal,
			&i.BackingCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMilestoneFund = `-- name: UpdateMilestoneFund :exec
UPDATE milestones
SET current_fund = current_fund + $2::bigint
WHERE id = $1
`

type UpdateMilestoneFundParams struct {
	ID     int64
	Amount int64
}

func (q *Queries) UpdateMilestoneFund(ctx context.Context, arg UpdateMilestoneFundParams) error {
	_, err := q.db.Exec(ctx, updateMilestoneFund, arg.ID, arg.Amount)
	return err
}

const updateProjectByID = `-- name: UpdateProjectByID :exec
UPDATE projects
SET title = $2, description = $3, cover_picture = $4, receiver_number=$5, receiver_name=$6, address=$7, district=$8, city=$9, country = $10, end_date = $11
WHERE id = $1
`

type UpdateProjectByIDParams struct {
	ID             int64
	Title          string
	Description    string
	CoverPicture   string
	ReceiverNumber string
	ReceiverName   string
	Address        string
	District       string
	City           string
	Country        string
	EndDate        time.Time
}

func (q *Queries) UpdateProjectByID(ctx context.Context, arg UpdateProjectByIDParams) error {
	_, err := q.db.Exec(ctx, updateProjectByID,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.CoverPicture,
		arg.ReceiverNumber,
		arg.ReceiverName,
		arg.Address,
		arg.District,
		arg.City,
		arg.Country,
		arg.EndDate,
	)
	return err
}

const updateProjectStatus = `-- name: UpdateProjectStatus :exec
UPDATE projects SET status = $2
WHERE id = $1
`

type UpdateProjectStatusParams struct {
	ID     int64
	Status NullProjectStatus
}

func (q *Queries) UpdateProjectStatus(ctx context.Context, arg UpdateProjectStatusParams) error {
	_, err := q.db.Exec(ctx, updateProjectStatus, arg.ID, arg.Status)
	return err
}
